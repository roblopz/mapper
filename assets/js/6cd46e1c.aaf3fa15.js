"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[1586],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=r.createContext({}),l=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(i.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(t),m=o,y=d["".concat(i,".").concat(m)]||d[m]||c[m]||a;return t?r.createElement(y,p(p({ref:n},u),{},{components:t})):r.createElement(y,p({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,p=new Array(a);p[0]=d;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,p[1]=s;for(var l=2;l<a;l++)p[l]=t[l];return r.createElement.apply(null,p)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8753:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return l},toc:function(){return u},default:function(){return d}});var r=t(3117),o=t(102),a=(t(7294),t(3905)),p=["components"],s={id:"classes-limitations",title:"Limitations",sidebar_label:"Limitations"},i=void 0,l={unversionedId:"plugins-system/classes-limitations",id:"plugins-system/classes-limitations",title:"Limitations",description:"Circular Dependencies",source:"@site/docs/plugins-system/classes-limitations.md",sourceDirName:"plugins-system",slug:"/plugins-system/classes-limitations",permalink:"/docs/plugins-system/classes-limitations",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/plugins-system/classes-limitations.md",tags:[],version:"current",lastUpdatedBy:"Chau Tran",lastUpdatedAt:1635280598,formattedLastUpdatedAt:"10/26/2021",frontMatter:{id:"classes-limitations",title:"Limitations",sidebar_label:"Limitations"},sidebar:"docs",previous:{title:"Metadata",permalink:"/docs/plugins-system/classes-metadata"},next:{title:"Transformer Plugin",permalink:"/docs/plugins-system/classes-transformer-plugin"}},u=[{value:"Circular Dependencies",id:"circular-dependencies",children:[{value:"Problem",id:"problem",children:[],level:3},{value:"TypeOrm Example",id:"typeorm-example",children:[],level:3},{value:"Solution",id:"solution",children:[],level:3}],level:2},{value:"Strict Mode",id:"strict-mode",children:[],level:2},{value:"Nested Array property",id:"nested-array-property",children:[],level:2}],c={toc:u};function d(e){var n=e.components,t=(0,o.Z)(e,p);return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"circular-dependencies"},"Circular Dependencies"),(0,a.kt)("h3",{id:"problem"},"Problem"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Circular Dependency")," occurs when you have two models that depend on each other. For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"SourceA")," depends on ",(0,a.kt)("inlineCode",{parentName:"p"},"SourceB")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SourceB")," also depends on ",(0,a.kt)("inlineCode",{parentName:"p"},"SourceA"),".\nWhen designing your data models, both Domain and DTO (or View Model), you will probably run into circular dependency."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class SourceA {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceB })\n  sourceB: SourceB;\n}\n\nclass SourceB {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceA })\n  sourceA: SourceA;\n}\n")),(0,a.kt)("h3",{id:"typeorm-example"},"TypeOrm Example"),(0,a.kt)("p",null,"This is very common when you set up your Entities using ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeOrm"),". Suppose you have two Entities: Order and Person"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Order {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @ManyToOne(() => Person, (person) => person.orders)\n  @AutoMap({ typeFn: () => Person })\n  person: Person;\n}\n\n@Entity()\nexport class Person {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @OneToMany(() => Order, (order) => order.person)\n  @AutoMap({ typeFn: () => Order })\n  orders: Order[];\n}\n")),(0,a.kt)("p",null,"Here, you have introduced a ",(0,a.kt)("strong",{parentName:"p"},"Circular Dependency")," with Order and Person."),(0,a.kt)("h3",{id:"solution"},"Solution"),(0,a.kt)("p",null,"In general, you should avoid introducing ",(0,a.kt)("strong",{parentName:"p"},"Circular Dependency")," as much as possible. However, there are cases that you must have ",(0,a.kt)("strong",{parentName:"p"},"Circular Dependency"),". For those cases, ",(0,a.kt)("inlineCode",{parentName:"p"},"@automapper/classes")," has a concept of ",(0,a.kt)("strong",{parentName:"p"},"depth")," of nesting models."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class SourceA {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceB })\n  sourceB: SourceB;\n}\n\nclass SourceB {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceA })\n  sourceA: SourceA;\n}\n")),(0,a.kt)("p",null,"Let's assume the above models, this is how ",(0,a.kt)("strong",{parentName:"p"},"depth")," works:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Depth of 0")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"SourceA {\n    sourceB: SourceB {\n        sourceA: null\n    }\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Depth of 1")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"SourceA {\n    sourceB: SourceB {\n        sourceA: SourceA {\n            sourceB: null;\n        }\n    }\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Depth of 2")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"SourceA {\n    sourceB: SourceB {\n        sourceA: SourceA {\n            sourceB: {\n                sourceA: SourceA {\n                    sourceB: null;\n                }\n            }\n        }\n    }\n}\n")),(0,a.kt)("p",null,"By default, ",(0,a.kt)("inlineCode",{parentName:"p"},"@automapper/classes")," will apply ",(0,a.kt)("strong",{parentName:"p"},"depth of 0")," to nested models. To specify ",(0,a.kt)("strong",{parentName:"p"},"depth"),", use ",(0,a.kt)("inlineCode",{parentName:"p"},"@AutoMap()")," decorator second argument:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class SourceA {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceB, depth: 1 })\n  sourceB: SourceB;\n}\n\nclass SourceB {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceA, depth: 1 })\n  sourceA: SourceA;\n}\n")),(0,a.kt)("p",null,"Please be advised that the bigger the ",(0,a.kt)("strong",{parentName:"p"},"depth")," is, the bigger your model is, so you need to be very cautious when you start introducing ",(0,a.kt)("strong",{parentName:"p"},"Circular Dependency"),"."),(0,a.kt)("p",null,"Another possible solution is to ",(0,a.kt)("strong",{parentName:"p"},"NOT")," decorate the circular-dependent member with ",(0,a.kt)("inlineCode",{parentName:"p"},"@AutoMap()")," and configure the mapping for this member manually with ",(0,a.kt)("inlineCode",{parentName:"p"},"mapWith()")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Order {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @ManyToOne(() => Person, (person) => person.orders)\n  person: Person;\n}\n\n@Entity()\nexport class Person {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @OneToMany(() => Order, (order) => order.person)\n  orders: Order[];\n}\n\nmapper.createMap(SomeOrderDto, Order).forMember(\n  (d) => d.person,\n  mapWith(Person, SomePersonDto, (s) => s.person)\n);\nmapper.createMap(SomePersonDto, Person).forMember(\n  (d) => d.orders,\n  mapWith(Order, SomeOrderDto, (s) => s.orders)\n);\n")),(0,a.kt)("h2",{id:"strict-mode"},"Strict Mode"),(0,a.kt)("p",null,"If you have ",(0,a.kt)("inlineCode",{parentName:"p"},"strict")," mode turned on, and you have ",(0,a.kt)("strong",{parentName:"p"},"Union Type")," on your properties like: ",(0,a.kt)("inlineCode",{parentName:"p"},"string | null"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number | null"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean | null"),"; you need to pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"typeFn")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"@AutoMap()")," like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export class User {\n  @AutoMap({ typeFn: () => String })\n  name!: string | null;\n  @AutoMap({ typeFn: () => Number })\n  age!: number | null;\n  @AutoMap({ typeFn: () => Boolean })\n  isAdmin!: boolean | null;\n}\n")),(0,a.kt)("p",null,"This is due to ",(0,a.kt)("strong",{parentName:"p"},"Weak Reflection")," when ",(0,a.kt)("inlineCode",{parentName:"p"},"strict")," mode is enabled."),(0,a.kt)("h2",{id:"nested-array-property"},"Nested Array property"),(0,a.kt)("p",null,"If your model contain array property and does not specify any ",(0,a.kt)("inlineCode",{parentName:"p"},"forMember()")," rule for them, then you ",(0,a.kt)("em",{parentName:"p"},"MUST")," provide ",(0,a.kt)("inlineCode",{parentName:"p"},"typeFn")," for it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class User {\n  @AutoMap()\n  firstName!: string;\n  @AutoMap()\n  lastName!: string;\n  @AutoMap()\n  profile!: UserProfile;\n  @AutoMap({ typeFn: () => Job }) // <- it's required for nested array property\n  jobs!: Job[];\n}\n\nmapper.createMap(User, UserVm);\n")),(0,a.kt)("p",null,"AutoMapper will attempt to get the data type of the property through reflection. In most cases, it will work without any problem, but for array property, it will only result an ",(0,a.kt)("inlineCode",{parentName:"p"},"Array")," type instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"Job[]")," above. It's currently an ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/issues/7169"},"open issue")," of TypeScript."),(0,a.kt)("p",null,"Or you can also use ",(0,a.kt)("inlineCode",{parentName:"p"},"mapWith()")," to let AutoMapper know its type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class User {\n  @AutoMap()\n  firstName!: string;\n  @AutoMap()\n  lastName!: string;\n  @AutoMap()\n  profile!: UserProfile;\n  @AutoMap() // <- omit typeFn\n  jobs!: Job[];\n}\n\nmapper.createMap(User, UserVm).forMember(\n  (d) => d.jobs,\n  mapWith(JobVm, Job, (s) => s.profile)\n);\n")))}d.isMDXComponent=!0}}]);