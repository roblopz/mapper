"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[1299],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return u}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),d=s(t),u=r,k=d["".concat(l,".").concat(u)]||d[u]||c[u]||o;return t?a.createElement(k,p(p({ref:n},m),{},{components:t})):a.createElement(k,p({ref:n},m))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,p=new Array(o);p[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,p[1]=i;for(var s=2;s<o;s++)p[s]=t[s];return a.createElement.apply(null,p)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9936:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return m},default:function(){return d}});var a=t(3117),r=t(102),o=(t(7294),t(3905)),p=["components"],i={id:"migrations",title:"Migrations",sidebar_label:"Migrations"},l=void 0,s={unversionedId:"migrations",id:"migrations",title:"Migrations",description:"Library Scope",source:"@site/docs/migrations.md",sourceDirName:".",slug:"/migrations",permalink:"/docs/migrations",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/migrations.md",tags:[],version:"current",lastUpdatedBy:"Chau Tran",lastUpdatedAt:1636729045,formattedLastUpdatedAt:"11/12/2021",frontMatter:{id:"migrations",title:"Migrations",sidebar_label:"Migrations"},sidebar:"docs",previous:{title:"NestJS",permalink:"/docs/nestjs"}},m=[{value:"Library Scope",id:"library-scope",children:[],level:2},{value:"Versioning",id:"versioning",children:[],level:2},{value:"Migrate from <code>@nartc/automapper</code>",id:"migrate-from-nartcautomapper",children:[{value:"Install <code>@automapper/*</code>",id:"install-automapper",children:[],level:3},{value:"Create a <code>Mapper</code> with <code>@automapper/classes</code>",id:"create-a-mapper-with-automapperclasses",children:[],level:3},{value:"Default settings",id:"default-settings",children:[],level:3},{value:"<code>Profile</code>",id:"profile",children:[],level:3},{value:"<code>Converter</code>",id:"converter",children:[],level:3},{value:"<code>Resolver</code>",id:"resolver",children:[],level:3},{value:"Inheritance",id:"inheritance",children:[],level:3},{value:"<code>MapAction</code> (aka callbacks)",id:"mapaction-aka-callbacks",children:[],level:3},{value:"Empty Values",id:"empty-values",children:[],level:3},{value:"Reverse Mapping",id:"reverse-mapping",children:[],level:3},{value:"<code>map()</code> variations API changes",id:"map-variations-api-changes",children:[],level:3},{value:"<code>skipUnmappedAssertion</code> is removed",id:"skipunmappedassertion-is-removed",children:[],level:3},{value:"<code>enum</code> properties",id:"enum-properties",children:[],level:3}],level:2},{value:"Migrate from <code>nestjsx-automapper</code>",id:"migrate-from-nestjsx-automapper",children:[{value:"Install <code>@automapper/nestjs</code> and <code>peerDependencies</code>",id:"install-automappernestjs-and-peerdependencies",children:[],level:3},{value:"Initialization",id:"initialization",children:[],level:3},{value:"<code>MappingProfile</code>",id:"mappingprofile",children:[],level:3}],level:2}],c={toc:m};function d(e){var n=e.components,t=(0,r.Z)(e,p);return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"library-scope"},"Library Scope"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/*")," are essentially two different packages. Technically, ",(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," is the base for ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/classes"),"."),(0,o.kt)("p",null,"In the near future, ",(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," will be archived (v7 would still be available) and will not receive any bug fixes or new features. All the effort will be spent toward ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/*"),"."),(0,o.kt)("h2",{id:"versioning"},"Versioning"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," is currently at v7. ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/*")," will start out with v1.0.0 and will strictly follow ",(0,o.kt)("a",{parentName:"p",href:"https://semver.org/"},"Semantic Versioning"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/*")," is a collection of packages that would all follow the same version number at any given time."),(0,o.kt)("h2",{id:"migrate-from-nartcautomapper"},"Migrate from ",(0,o.kt)("inlineCode",{parentName:"h2"},"@nartc/automapper")),(0,o.kt)("h3",{id:"install-automapper"},"Install ",(0,o.kt)("inlineCode",{parentName:"h3"},"@automapper/*")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @automapper/{core,classes}\n# or with yarn\nyarn add @automapper/{core,classes}\n")),(0,o.kt)("h3",{id:"create-a-mapper-with-automapperclasses"},"Create a ",(0,o.kt)("inlineCode",{parentName:"h3"},"Mapper")," with ",(0,o.kt)("inlineCode",{parentName:"h3"},"@automapper/classes")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," does not expose a ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," constant anymore because ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," operates based on a ",(0,o.kt)("inlineCode",{parentName:"p"},"MapPlugin")," you pick, and you can have multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," for each plugin."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Mapper } from '@nartc/automapper';\n\nMapper.createMap(...);\n\n// after\nimport { createMapper } from '@automapper/core';\nimport { classes } from '@automapper/classes';\n\nconst mapper = createMapper({\n  name: 'arbitrary name',\n  pluginInitializer: classes\n})\n\nmapper.createMap(...);\n")),(0,o.kt)("h3",{id:"default-settings"},"Default settings"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," sets some default settings which are ",(0,o.kt)("inlineCode",{parentName:"p"},"NamingConvention")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrorHandler"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," does not set any default ",(0,o.kt)("inlineCode",{parentName:"p"},"NamingConvention")," and it sets ",(0,o.kt)("inlineCode",{parentName:"p"},"console.error")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrorHandler#handle"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const mapper = createMapper({\n  name: 'arbitrary name',\n  pluginInitializer: classes,\n  namingConventions: new CamelCaseNamingConvention(),\n});\n")),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrorHandler"),", it is now an interface with a ",(0,o.kt)("inlineCode",{parentName:"p"},"handle")," method so you can just provide that as well"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const mapper = createMapper({\n  name: 'arbitrary name',\n  pluginInitializer: classes,\n  namingConventions: new CamelCaseNamingConvention(),\n  errorHandler: {\n    handle: (error) => {\n      // custom error handler\n    },\n  },\n});\n")),(0,o.kt)("h3",{id:"profile"},(0,o.kt)("inlineCode",{parentName:"h3"},"Profile")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Profile")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," is just a function that accepts the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapper")," object and returns nothing (",(0,o.kt)("inlineCode",{parentName:"p"},"void"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { ProfileBase } from '@nartc/automapper';\n\nexport class UserProfile extends ProfileBase {\n  constructor(mapper: AutoMapper) {\n    super()\n    mapper.createMap(...)\n  }\n}\n\n// after\nimport type { MappingProfile } from '@automapper/core';\n\nexport const userProfile: MappingProfile = mapper => {\n  mapper.createMap(...)\n}\n")),(0,o.kt)("h3",{id:"converter"},(0,o.kt)("inlineCode",{parentName:"h3"},"Converter")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Converter")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," is just an object with the ",(0,o.kt)("inlineCode",{parentName:"p"},"convert")," method that accepts a ",(0,o.kt)("inlineCode",{parentName:"p"},"sourceData")," and returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"destinationData"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Converter } from '@nartc/automapper';\n\nexport class DateStringConverter implements Converter<Date, string> {\n  convert(source: Date): string {\n    return source.toDateString();\n  }\n}\n\n// after\nimport type { Converter } from '@automapper/core';\n\nexport const dateStringConverter: Converter<Date, string> = {\n  convert(source) {\n    return source.toDateString();\n  },\n};\n")),(0,o.kt)("h3",{id:"resolver"},(0,o.kt)("inlineCode",{parentName:"h3"},"Resolver")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Resolver")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," is just an object with the ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve")," method that accepts a ",(0,o.kt)("inlineCode",{parentName:"p"},"(source, destination?)")," and returns data that matches with ",(0,o.kt)("inlineCode",{parentName:"p"},"destination#member")," type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Resolver } from '@nartc/automapper';\n\nexport class TaxResolver implements Resolver<Item, ItemDto, number> {\n  resolve(source: Item): number {\n    return source.type === 'A' ? source.price * 0.5 : source.price * 0.9;\n  }\n}\n\n// after\nimport type { Resolver } from '@automapper/core';\n\nexport const taxResolver: Resolver<Item, ItemDto, number> = {\n  resolve(source) {\n    return source.type === 'A' ? source.price * 0.5 : source.price * 0.9;\n  },\n};\n")),(0,o.kt)("h3",{id:"inheritance"},"Inheritance"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class Base {...}\nclass BaseDto {...}\n\nclass User extends Base {...}\nclass UserDto extends BaseDto {...}\n\n// before\nimport { Mapper } from '@nartc/automapper';\n\nMapper.createMap(Base, BaseDto);\nMapper.createMap(User, UserDto, { includeBase: [Base, BaseDto] });\n\n// after\nimport { mapper } from 'your/path/to/your-mapper'\n\nmapper.createMap(Base, BaseDto);\nmapper.createMap(User, UserDto, { extends: [mapper.getMapping(Base, BaseDto)] })\n")),(0,o.kt)("p",null,"This approach allows you to have ",(0,o.kt)("inlineCode",{parentName:"p"},"Mapping<User, UserDto>")," extends as many mappings as possible. There's a downside that is the typings for ",(0,o.kt)("inlineCode",{parentName:"p"},"extends")," is a little loose."),(0,o.kt)("h3",{id:"mapaction-aka-callbacks"},(0,o.kt)("inlineCode",{parentName:"h3"},"MapAction")," (aka callbacks)"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"beforeMap")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"afterMap")," work the same as before. However, they will be invoked with ",(0,o.kt)("inlineCode",{parentName:"p"},"(source, destination)")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"(source, destination, mapping)")),(0,o.kt)("h3",{id:"empty-values"},"Empty Values"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," dictates ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," to assign to empty values. ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," will not do this. All empty values will be ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," will still be mapped to ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,o.kt)("h3",{id:"reverse-mapping"},"Reverse Mapping"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"reverseMap()")," has been removed in ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/*"),". The reason is Reverse Mapping is very tricky to get right, and it requires a lot of code to make it work, and it is not even working correctly."),(0,o.kt)("p",null,"If you need ",(0,o.kt)("inlineCode",{parentName:"p"},"reverseMap()"),", just call ",(0,o.kt)("inlineCode",{parentName:"p"},"createMap()")," with the models again."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nMapper.createMap(User, UserDto).reverseMap();\n\n// after\nmapper.createMap(User, UserDto);\nmapper.createMap(UserDto, User);\n")),(0,o.kt)("h3",{id:"map-variations-api-changes"},(0,o.kt)("inlineCode",{parentName:"h3"},"map()")," variations API changes"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," works only with Class so the ",(0,o.kt)("inlineCode",{parentName:"p"},"map()")," method in ",(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," makes passing in the ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," type optional and will try to guess the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," with: ",(0,o.kt)("inlineCode",{parentName:"p"},"sourceObj.constructor"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core")," works with different type now so ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," type has been made mandatory."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nMapper.map(sourceObj, Destination);\n\n// after\nmapper.map(sourceObj, Destination, Source);\n")),(0,o.kt)("h3",{id:"skipunmappedassertion-is-removed"},(0,o.kt)("inlineCode",{parentName:"h3"},"skipUnmappedAssertion")," is removed"),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrorHandler#handle")," is default to ",(0,o.kt)("inlineCode",{parentName:"p"},"console.error"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"skipUnmappedAssertion")," was added to ",(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," to prevent having a thrown exception leading to a crash. It is not needed with ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/core"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: In the event of unmapped properties, the error is still be logged to the Console. If this is something you do not want, please ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nartc/mapper/issues"},"open an Issue"))),(0,o.kt)("h3",{id:"enum-properties"},(0,o.kt)("inlineCode",{parentName:"h3"},"enum")," properties"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@AutoMap()")," on enum properties might behave differently based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig")," that your application is using (either for serving or building). If you run into issues with Enum properties, provide additional information for ",(0,o.kt)("inlineCode",{parentName:"p"},"@AutoMap()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// string enum\n@AutoMap({ typeFn: () => String })\nrole: UserRole\n\n// number enum\n@AutoMap({ typeFn: () => Number })\nrole: UserRole\n")),(0,o.kt)("p",null,"This might not be the case for ",(0,o.kt)("inlineCode",{parentName:"p"},"@nartc/automapper")," but the ",(0,o.kt)("inlineCode",{parentName:"p"},"@AutoMap()")," decorator is reworked a little (to be lighter and more consistent) in ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/classes"),"."),(0,o.kt)("h2",{id:"migrate-from-nestjsx-automapper"},"Migrate from ",(0,o.kt)("inlineCode",{parentName:"h2"},"nestjsx-automapper")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"nestjsx-automapper")," will also be archived due to the release of ",(0,o.kt)("inlineCode",{parentName:"p"},"@automapper/nestjs")," which is the official integration package with ",(0,o.kt)("a",{parentName:"p",href:"https://nestjs.com"},"NestJS")),(0,o.kt)("h3",{id:"install-automappernestjs-and-peerdependencies"},"Install ",(0,o.kt)("inlineCode",{parentName:"h3"},"@automapper/nestjs")," and ",(0,o.kt)("inlineCode",{parentName:"h3"},"peerDependencies")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @automapper/{core,classes,nestjs}\n# or with yarn\nyarn add @automapper/{core,classes,nestjs}\n")),(0,o.kt)("h3",{id:"initialization"},"Initialization"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { AutomapperModule } from 'nestjsx-automapper';\n\n@Module({\n  imports: [AutomapperModule.withMapper()],\n})\nexport class AppModule {}\n\n// after\nimport { AutomapperModule } from '@automapper/nestjs';\nimport { classes } from '@automapper/classes';\n\n@Module({\n  imports: [\n    AutomapperModule.forRoot({\n      options: [\n        // can initialize multiple mappers for each plugins\n        {\n          name: 'arbitrary name',\n          pluginInitializer: classes,\n          namingConventions: new CamelCaseNamingConvention(),\n        },\n      ],\n      singular: true, // default to false. set to true if you want to use `InjectMapper()` without passing in anything\n    }),\n  ],\n})\nexport class AppModule {}\n")),(0,o.kt)("h3",{id:"mappingprofile"},(0,o.kt)("inlineCode",{parentName:"h3"},"MappingProfile")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Profile, ProfileBase, AutoMapper } from 'nestjsx-automapper';\n\n@Profile()\nexport class UserProfile extends ProfileBase {\n  constructor(mapper: AutoMapper) {\n    super();\n    mapper.createMap(...)\n  }\n}\n\n// in some other files that are guaranteed to load by webpack\nimport 'path/to/profile'\n\n\n// after\nimport { Injectable } from '@nestjs/common';\nimport { AutomapperProfile, InjectMapper } from '@automapper/nestjs';\nimport type { Mapper } from '@automapper/core';\n\n@Injectable()\nexport class UserProfile extends AutomapperProfile {\n  constructor(@InjectMapper() mapper: Mapper) { // can inject other services\n    super(mapper);\n  }\n\n  mapProfile() {\n    return mapper => {\n      mapper.createMap(...)\n    }\n  }\n}\n\n// in some module\n@Module({\n  imports: [...],\n  providers: [UserProfile]\n})\nexport class SomeModule {}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"mapProfile()")," will be called automatically by ",(0,o.kt)("inlineCode",{parentName:"p"},"AutomapperProfile"),"."))}d.isMDXComponent=!0}}]);